#!/usr/bin/env bash
set -euo pipefail

REPO_OWNER="PasarGuard"
REPO_NAME="migrations"
SERVICE_NAME="redirect-server"
SERVICE_DESCRIPTION="Subscription URL Redirect Server"
SERVICE_USER="redirectsrv"
INSTALL_DIR="/opt/${SERVICE_NAME}"
CONFIG_DIR="/etc/${SERVICE_NAME}"
BIN_PATH="/usr/local/bin/${SERVICE_NAME}"
SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"

VERSION="${1:-latest}"
ASSET_NAME_OVERRIDE="${ASSET_NAME_OVERRIDE:-${ASSET_NAME:-}}"

require_root() {
  if [[ "$(id -u)" -ne 0 ]]; then
    echo "This installer must be run as root." >&2
    exit 1
  fi
}

PACKAGE_MANAGER=""
APT_UPDATED=0

detect_package_manager() {
  if [[ -n "${PACKAGE_MANAGER}" ]]; then
    return
  fi
  if command -v apt-get >/dev/null 2>&1; then
    PACKAGE_MANAGER="apt"
  elif command -v dnf >/dev/null 2>&1; then
    PACKAGE_MANAGER="dnf"
  elif command -v yum >/dev/null 2>&1; then
    PACKAGE_MANAGER="yum"
  elif command -v pacman >/dev/null 2>&1; then
    PACKAGE_MANAGER="pacman"
  elif command -v zypper >/dev/null 2>&1; then
    PACKAGE_MANAGER="zypper"
  elif command -v apk >/dev/null 2>&1; then
    PACKAGE_MANAGER="apk"
  else
    PACKAGE_MANAGER="unknown"
  fi
}

install_package() {
  local pkg="$1"
  detect_package_manager
  case "${PACKAGE_MANAGER}" in
    apt)
      if [[ "${APT_UPDATED}" -eq 0 ]]; then
        apt-get update
        APT_UPDATED=1
      fi
      apt-get install -y "${pkg}"
      ;;
    dnf)
      dnf install -y "${pkg}"
      ;;
    yum)
      yum install -y "${pkg}"
      ;;
    pacman)
      pacman -Sy --noconfirm "${pkg}"
      ;;
    zypper)
      zypper install -y "${pkg}"
      ;;
    apk)
      apk add --no-cache "${pkg}"
      ;;
    *)
      echo "Missing command '${pkg}' and no supported package manager found. Please install it manually." >&2
      exit 1
      ;;
  esac
}

ensure_cmd() {
  local cmd="$1"
  local pkg="${2:-$1}"
  if command -v "${cmd}" >/dev/null 2>&1; then
    return
  fi
  echo "Command '${cmd}' not found. Attempting to install '${pkg}'..."
  install_package "${pkg}"
  if ! command -v "${cmd}" >/dev/null 2>&1; then
    echo "Failed to install command '${cmd}'. Please install it manually and rerun the installer." >&2
    exit 1
  fi
}

detect_target_os() {
  case "$(uname -s)" in
    Linux)  echo "linux" ;;
    *)      echo "Unsupported OS for this installer (requires Linux with systemd)." >&2; exit 1 ;;
  esac
}

detect_target_arch() {
  case "$(uname -m)" in
    x86_64|amd64) echo "amd64" ;;
    aarch64|arm64) echo "arm64" ;;
    armv7l|armv7hf) echo "armv7" ;;
    *) echo "Unsupported architecture: $(uname -m)" >&2; exit 1 ;;
  esac
}

fetch_release_metadata() {
  local api_url
  if [[ "${VERSION}" == "latest" ]]; then
    api_url="https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/latest"
  else
    api_url="https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/tags/${VERSION}"
  fi
  curl -fsSL "${api_url}"
}

select_asset() {
  local override="${ASSET_NAME_OVERRIDE}"
  if [[ -n "${override}" ]]; then
    if ! jq -er --arg name "${override}" '
        .assets
        | map(select(.name == $name))
        | .[0]
        | "\(.browser_download_url)\n\(.name)"
      '; then
      echo "Could not find asset named '${override}' in the release." >&2
      return 1
    fi
    return 0
  fi

  if ! jq -er \
      --arg os "${TARGET_OS}" \
      --arg arch_pattern "${ASSET_ARCH_PATTERN}" '
        .assets
        | map(select((.name | ascii_downcase) | contains($os)))
        | map(select((.name | ascii_downcase) | test($arch_pattern)))
        | .[0]
        | "\(.browser_download_url)\n\(.name)"
      '; then
    echo "Could not find an asset matching OS '${TARGET_OS}' and arch '${TARGET_ARCH}'." >&2
    return 1
  fi
}

create_system_user() {
  if id -u "${SERVICE_USER}" >/dev/null 2>&1; then
    return
  fi

  useradd \
    --system \
    --home "${INSTALL_DIR}" \
    --shell /usr/sbin/nologin \
    --comment "${SERVICE_DESCRIPTION}" \
    "${SERVICE_USER}"
}

install_service_file() {
  cat > "${SERVICE_FILE}" <<EOF
[Unit]
Description=${SERVICE_DESCRIPTION}
After=network.target

[Service]
Type=simple
User=${SERVICE_USER}
Group=${SERVICE_USER}
WorkingDirectory=${INSTALL_DIR}
ExecStart=${BIN_PATH} --config ${CONFIG_DIR}/config.json --map ${CONFIG_DIR}/subscription_url_mapping.json
Restart=on-failure
RestartSec=5s
Environment=CONFIG_PATH=${CONFIG_DIR}/config.json
Environment=MAP_PATH=${CONFIG_DIR}/subscription_url_mapping.json

[Install]
WantedBy=multi-user.target
EOF
}

prompt_for_map_file() {
  echo
  echo "=== URL Mapping File Setup ==="
  echo "The redirect server needs a URL mapping file (subscription_url_mapping.json)"
  echo "This file should be generated by the migration tool."
  echo

  local map_source=""
  
  # Check if provided via environment variable
  if [[ -n "${MAP_FILE:-}" ]]; then
    map_source="${MAP_FILE}"
    echo "Using mapping file from MAP_FILE environment variable: ${map_source}"
  elif [[ -t 0 ]]; then
    # Interactive mode - stdin is a TTY
    while true; do
      read -p "Enter the path to your subscription_url_mapping.json file: " map_source

      if [[ -z "${map_source}" ]]; then
        echo "Error: Path cannot be empty." >&2
        continue
      fi

      # Expand tilde to home directory
      map_source="${map_source/#\~/$HOME}"

      if [[ ! -f "${map_source}" ]]; then
        echo "Error: File '${map_source}' does not exist." >&2
        continue
      fi

      # Validate JSON
      if ! jq empty "${map_source}" 2>/dev/null; then
        echo "Error: File '${map_source}' is not valid JSON." >&2
        continue
      fi

      break
    done
  else
    # Non-interactive mode - try common locations
    local common_paths=(
      "${HOME}/migrations/marzneshin/subscription_url_mapping.json"
      "${HOME}/subscription_url_mapping.json"
      "./subscription_url_mapping.json"
      "/tmp/subscription_url_mapping.json"
    )
    
    echo "Non-interactive mode detected. Searching for mapping file..."
    for path in "${common_paths[@]}"; do
      if [[ -f "${path}" ]]; then
        if jq empty "${path}" 2>/dev/null; then
          map_source="${path}"
          echo "Found mapping file at: ${map_source}"
          break
        fi
      fi
    done
    
    if [[ -z "${map_source}" ]]; then
      echo "Error: Could not find subscription_url_mapping.json file." >&2
      echo "Please either:" >&2
      echo "  1) Set MAP_FILE environment variable: MAP_FILE=/path/to/file" >&2
      echo "  2) Place the file in one of these locations:" >&2
      printf "     - %s\n" "${common_paths[@]}" >&2
      echo "  3) Run the installer interactively (not piped)" >&2
      exit 1
    fi
  fi

  # Expand tilde to home directory
  map_source="${map_source/#\~/$HOME}"

  if [[ ! -f "${map_source}" ]]; then
    echo "Error: File '${map_source}' does not exist." >&2
    exit 1
  fi

  # Validate JSON
  if ! jq empty "${map_source}" 2>/dev/null; then
    echo "Error: File '${map_source}' is not valid JSON." >&2
    exit 1
  fi

  # Copy the file
  cp "${map_source}" "${CONFIG_DIR}/subscription_url_mapping.json"
  chown "${SERVICE_USER}:${SERVICE_USER}" "${CONFIG_DIR}/subscription_url_mapping.json"
  chmod 0640 "${CONFIG_DIR}/subscription_url_mapping.json"

  local mapping_count
  mapping_count=$(jq '.mappings | length' "${CONFIG_DIR}/subscription_url_mapping.json" 2>/dev/null || echo "0")
  echo "✓ Successfully loaded mapping file with ${mapping_count} user mappings."
}

prompt_for_config() {
  echo
  echo "=== Server Configuration Setup ==="
  
  # Check if config already exists
  if [[ -f "${CONFIG_DIR}/config.json" ]]; then
    echo "Configuration file already exists at ${CONFIG_DIR}/config.json"
    echo "Skipping configuration setup. To reconfigure, delete the file and rerun."
    return
  fi
  
  # Check if provided via environment variable
  if [[ -n "${CONFIG_FILE:-}" ]]; then
    echo "Using config file from CONFIG_FILE environment variable: ${CONFIG_FILE}"
    prompt_existing_config_with_path "${CONFIG_FILE}"
    return
  fi

  echo "You can either provide an existing config.json file or create one interactively."
  echo

  local choice=""
  if [[ -t 0 ]]; then
    # Interactive mode
    while [[ "${choice}" != "1" && "${choice}" != "2" ]]; do
      echo "Choose an option:"
      echo "  1) Provide existing config.json file path"
      echo "  2) Create configuration interactively"
      read -p "Enter choice (1 or 2): " choice
    done

    if [[ "${choice}" == "1" ]]; then
      prompt_existing_config
    else
      prompt_interactive_config
    fi
  else
    # Non-interactive mode - create default config
    echo "Non-interactive mode detected. Creating default configuration..."
    create_default_config
  fi
}

prompt_existing_config() {
  local config_source=""
  while true; do
    read -p "Enter the path to your config.json file: " config_source

    if [[ -z "${config_source}" ]]; then
      echo "Error: Path cannot be empty." >&2
      continue
    fi

    # Expand tilde to home directory
    config_source="${config_source/#\~/$HOME}"

    if [[ ! -f "${config_source}" ]]; then
      echo "Error: File '${config_source}' does not exist." >&2
      continue
    fi

    # Validate JSON
    if ! jq empty "${config_source}" 2>/dev/null; then
      echo "Error: File '${config_source}' is not valid JSON." >&2
      continue
    fi

    # Copy the file
    cp "${config_source}" "${CONFIG_DIR}/config.json"
    chown "${SERVICE_USER}:${SERVICE_USER}" "${CONFIG_DIR}/config.json"
    chmod 0640 "${CONFIG_DIR}/config.json"

    echo "✓ Successfully loaded configuration file."
    break
  done
}

prompt_existing_config_with_path() {
  local config_source="$1"
  
  # Expand tilde to home directory
  config_source="${config_source/#\~/$HOME}"

  if [[ ! -f "${config_source}" ]]; then
    echo "Error: File '${config_source}' does not exist." >&2
    exit 1
  fi

  # Validate JSON
  if ! jq empty "${config_source}" 2>/dev/null; then
    echo "Error: File '${config_source}' is not valid JSON." >&2
    exit 1
  fi

  # Copy the file
  cp "${config_source}" "${CONFIG_DIR}/config.json"
  chown "${SERVICE_USER}:${SERVICE_USER}" "${CONFIG_DIR}/config.json"
  chmod 0640 "${CONFIG_DIR}/config.json"

  echo "✓ Successfully loaded configuration file."
}

create_default_config() {
  echo "Creating default configuration (HTTP on port 8080)..."
  jq -n \
    --arg host "0.0.0.0" \
    --argjson port 8080 \
    --arg redirect_domain "" \
    --argjson ssl_enabled false \
    --arg ssl_cert "" \
    --arg ssl_key "" \
    '{
      host: $host,
      port: $port,
      redirect_domain: $redirect_domain,
      ssl: {
        enabled: $ssl_enabled,
        cert: $ssl_cert,
        key: $ssl_key
      }
    }' > "${CONFIG_DIR}/config.json"

  chown "${SERVICE_USER}:${SERVICE_USER}" "${CONFIG_DIR}/config.json"
  chmod 0640 "${CONFIG_DIR}/config.json"

  echo "✓ Default configuration file created successfully."
  echo "  You can edit ${CONFIG_DIR}/config.json to customize settings."
}

prompt_interactive_config() {
  echo
  echo "Let's configure the redirect server:"

  # Port
  local port="8080"
  read -p "Enter port number [8080]: " port
  port="${port:-8080}"

  # Redirect domain
  echo
  echo "Redirect domain (optional):"
  echo "  - Leave empty to use the same domain as the incoming request"
  echo "  - Or specify a domain like: https://new.example.com"
  local redirect_domain=""
  read -p "Enter redirect domain [leave empty for same domain]: " redirect_domain

  # SSL
  echo
  local ssl_enabled="false"
  local ssl_cert=""
  local ssl_key=""

  read -p "Enable SSL/HTTPS? (y/N): " ssl_choice
  if [[ "${ssl_choice,,}" == "y" || "${ssl_choice,,}" == "yes" ]]; then
    ssl_enabled="true"

    echo
    echo "SSL Certificate setup:"
    echo "  You can provide either:"
    echo "    1) Path to PEM certificate file"
    echo "    2) Paste the certificate content directly"

    local cert_choice=""
    while [[ "${cert_choice}" != "1" && "${cert_choice}" != "2" ]]; do
      read -p "Enter choice (1 or 2): " cert_choice
    done

    if [[ "${cert_choice}" == "1" ]]; then
      local cert_path=""
      while [[ ! -f "${cert_path}" ]]; do
        read -p "Enter path to SSL certificate file: " cert_path
        cert_path="${cert_path/#\~/$HOME}"
        if [[ ! -f "${cert_path}" ]]; then
          echo "Error: File not found." >&2
        fi
      done
      ssl_cert=$(cat "${cert_path}")
    else
      echo "Paste your SSL certificate (PEM format), end with a line containing only 'EOF':"
      ssl_cert=""
      while IFS= read -r line; do
        [[ "${line}" == "EOF" ]] && break
        ssl_cert="${ssl_cert}${line}\n"
      done
      ssl_cert=$(echo -e "${ssl_cert}")
    fi

    echo
    echo "SSL Private Key setup:"
    local key_choice=""
    while [[ "${key_choice}" != "1" && "${key_choice}" != "2" ]]; do
      echo "  1) Path to PEM private key file"
      echo "  2) Paste the private key content directly"
      read -p "Enter choice (1 or 2): " key_choice
    done

    if [[ "${key_choice}" == "1" ]]; then
      local key_path=""
      while [[ ! -f "${key_path}" ]]; do
        read -p "Enter path to SSL private key file: " key_path
        key_path="${key_path/#\~/$HOME}"
        if [[ ! -f "${key_path}" ]]; then
          echo "Error: File not found." >&2
        fi
      done
      ssl_key=$(cat "${key_path}")
    else
      echo "Paste your SSL private key (PEM format), end with a line containing only 'EOF':"
      ssl_key=""
      while IFS= read -r line; do
        [[ "${line}" == "EOF" ]] && break
        ssl_key="${ssl_key}${line}\n"
      done
      ssl_key=$(echo -e "${ssl_key}")
    fi
  fi

  # Generate config.json using jq
  jq -n \
    --arg host "0.0.0.0" \
    --argjson port "${port}" \
    --arg redirect_domain "${redirect_domain}" \
    --argjson ssl_enabled "${ssl_enabled}" \
    --arg ssl_cert "${ssl_cert}" \
    --arg ssl_key "${ssl_key}" \
    '{
      host: $host,
      port: $port,
      redirect_domain: $redirect_domain,
      ssl: {
        enabled: $ssl_enabled,
        cert: $ssl_cert,
        key: $ssl_key
      }
    }' > "${CONFIG_DIR}/config.json"

  chown "${SERVICE_USER}:${SERVICE_USER}" "${CONFIG_DIR}/config.json"
  chmod 0640 "${CONFIG_DIR}/config.json"

  echo
  echo "✓ Configuration file created successfully."
}

reload_and_start_service() {
  systemctl daemon-reload
  systemctl enable --now "${SERVICE_NAME}.service"
  systemctl status "${SERVICE_NAME}.service" --no-pager
}

INSTALLER_TMP_DIR=""

cleanup_temp_dir() {
  if [[ -n "${INSTALLER_TMP_DIR:-}" && -d "${INSTALLER_TMP_DIR}" ]]; then
    rm -rf "${INSTALLER_TMP_DIR}"
  fi
}

main() {
  require_root
  ensure_cmd curl
  ensure_cmd jq
  ensure_cmd tar
  ensure_cmd readlink coreutils

  if ! command -v systemctl >/dev/null 2>&1; then
    echo "systemctl is required but not found. This installer targets systemd-based systems." >&2
    exit 1
  fi

  local target_os target_arch arch_pattern release_json asset_info asset_url asset_name bin_source

  target_os="$(detect_target_os)"
  target_arch="$(detect_target_arch)"
  arch_pattern="${target_arch}"
  case "${target_arch}" in
    amd64) arch_pattern="amd64|x86_64" ;;
    arm64) arch_pattern="arm64|aarch64" ;;
    armv7) arch_pattern="armv7|armhf|armv7l" ;;
  esac
  export TARGET_OS="${target_os}"
  export TARGET_ARCH="${target_arch}"
  export ASSET_ARCH_PATTERN="${arch_pattern}"
  export ASSET_NAME_OVERRIDE

  release_json="$(fetch_release_metadata)"
  mapfile -t asset_info < <(printf '%s' "${release_json}" | select_asset)

  asset_url="${asset_info[0]:-}"
  asset_name="${asset_info[1]:-}"
  if [[ -z "${asset_url}" || -z "${asset_name}" ]]; then
    echo "Unable to resolve a download URL for the release asset." >&2
    exit 1
  fi

  echo "Downloading ${asset_name} from GitHub releases..."

  INSTALLER_TMP_DIR="$(mktemp -d)"
  trap 'cleanup_temp_dir' EXIT

  curl -fsSLo "${INSTALLER_TMP_DIR}/${asset_name}" "${asset_url}"

  pushd "${INSTALLER_TMP_DIR}" >/dev/null
  bin_source=""
  case "${asset_name}" in
    *.tar.gz|*.tgz)
      tar -xzf "${asset_name}"
      ;;
    *.tar.xz|*.txz)
      tar -xJf "${asset_name}"
      ;;
    *.tar)
      tar -xf "${asset_name}"
      ;;
    *.zip)
      ensure_cmd unzip
      unzip -q "${asset_name}"
      ;;
    *)
      chmod +x "${asset_name}" 2>/dev/null || true
      if [[ -x "${asset_name}" ]]; then
        bin_source="$(pwd)/${asset_name}"
      else
        echo "Unsupported archive format for ${asset_name}. Expected a tar/zip archive or raw executable." >&2
        exit 1
      fi
      ;;
  esac

  if [[ -z "${bin_source}" ]]; then
    bin_source="$(find . -maxdepth 3 -type f -perm -111 -name "${SERVICE_NAME}" | head -n 1)"
    if [[ -z "${bin_source}" ]]; then
      echo "Failed to locate the '${SERVICE_NAME}' binary inside the downloaded archive." >&2
      exit 1
    fi
  fi
  bin_source="$(readlink -f "${bin_source}")"
  popd >/dev/null

  install -d -m 0755 "${INSTALL_DIR}"
  install -d -m 0750 "${CONFIG_DIR}"
  install -D -m 0755 "${bin_source}" "${BIN_PATH}"

  create_system_user
  chown -R "${SERVICE_USER}:${SERVICE_USER}" "${INSTALL_DIR}" "${CONFIG_DIR}"

  # Interactive configuration
  prompt_for_map_file
  prompt_for_config

  install_service_file
  chmod 0644 "${SERVICE_FILE}"

  reload_and_start_service

  echo
  echo "============================================"
  echo "Installation complete!"
  echo "============================================"
  echo
  echo "Service: ${SERVICE_NAME}"
  echo "Status: Running"
  echo "Config: ${CONFIG_DIR}/config.json"
  echo "Mapping: ${CONFIG_DIR}/subscription_url_mapping.json"
  echo
  echo "Useful commands:"
  echo "  sudo systemctl status ${SERVICE_NAME}   # View service status"
  echo "  sudo systemctl restart ${SERVICE_NAME}  # Restart service"
  echo "  sudo systemctl stop ${SERVICE_NAME}     # Stop service"
  echo "  sudo journalctl -u ${SERVICE_NAME} -f   # View logs"
  echo
  echo "To update configuration or mapping files, edit the files in ${CONFIG_DIR}/ and restart the service."
}

main "$@"
